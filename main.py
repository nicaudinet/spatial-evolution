from itertools import repeat
from math import log2
import numpy as np
import random
import time
import copy
import itertools

C = 'c' # Cooperate
D = 'd' # Defect
A = 'a' # Abstain

ALL_ACTIONS = [C,D,A]

# T > R > L > P > S
# to compare with prisoners dilemma
T = 5
R = 3
L = 2
P = 1
S = 0

P1 = 0
P2 = 1

class History:
    def __init__(self):
        self.p1 = ''
        self.p2 = ''
        self.score1 = 0
        self.score2 = 0

        self.scores = np.array([
            [[R,R],  [S,T],  [L,L],],
            [[T,S],  [P,P],  [L,L],],
            [[L,L],  [L,L],  [L,L],],
        ])

        self.action_idx_map = {
            'c': 0,
            'd': 1,
            'a': 2,
        }
    
    def put(self, action1, action2):
        """ Store the results of a round (the two actions generated by the two
        players) into the history. """

        self.p1 += action1 + action2
        self.p2 += action2 + action1

        # make sure that only one action is passed on, only happens when initial state is put
        self.update_score(action1[-1], action2[-1])

    def update_score(self, a1, a2):
        """ Evaluate the history of the two players for Prisoner's Dilemma,
        where:
                  a2
                C    D    A
        a1  C  R,R  S,T  L,L
            D  T,S  P,P  L,L
            A  L,L  L,L  L,L
            """

        a1_idx = self.action_idx_map[a1]
        a2_idx = self.action_idx_map[a2]

        self.score1 += self.scores[a1_idx, a2_idx, P1]
        self.score2 += self.scores[a1_idx, a2_idx, P2]

    def print(self):
        """ Pretty print the history """
        print("P1 | P2")
        print("-------")
        actions = list(self.p1)
        for i in range(0, len(actions), 2):
            a1 = actions[i]
            a2 = actions[i+1]
            print(" %s | %s " % (a1,a2))

class Player:
    def __init__(self, strategy, initial_state):
        self.score = 0
        self.memory_size = 1
        self.strategy = strategy
        self.initial_state = initial_state

def play_turn(strat, history, mistake):
    """ Play a single turn for a single player with some probability of a
    mistake happening """
    action = strat[history]

    if random.random() < mistake:
        return not_action(action)
    else:
        return action

def play_game(player1, player2, mistake, rounds):
    """ Play a game between two players from start to finish """

    # Find the largest memory m
    m1 = max([len(k) for k in player1.strategy.keys()])
    m2 = max([len(k) for k in player2.strategy.keys()])

    # Create random initial history
    history = History()
    for i in range(max(m1, m2)):
        a1 = player1.initial_state
        a2 = player2.initial_state
        history.put(a1,a2)

    # Play the game out
    for r in range(rounds):
        # Player 1 plays
        hist1 = history.p1[-m1:]
        action1 = play_turn(player1.strategy, hist1, mistake)
        # Player 2 plays
        hist2 = history.p2[-m2:]
        action2 = play_turn(player2.strategy, hist2, mistake)
        # Store the results
        history.put(action1, action2)
    return history

def play_all(population, mistake, rounds):
    for player1 in population:
        for player2 in population:
            history = play_game(player1, player2, mistake, rounds)

            player1.score += history.score1
            player2.score += history.score2
    
    return population

# Lattice play
# ------------
def play_neighbors(lat, i, j, mistake, rounds):
    n = len(lat)
    up    = n - 1 if i == 0     else i - 1
    down  = 0     if i == n - 1 else i + 1
    left  = n - 1 if j == 0     else j - 1
    right = 0     if j == n - 1 else j + 1

    # Strats
    my_strat = lat[i][j]
    up_neighba, down_neighba, left_neighba, right_neighba = lat[up][j], lat[down][j], lat[i][left], lat[i][right]
    
    # Result of playing neighbas
    payoff_up, payoff_down, payoff_left, payoff_right = play_game(my_strat['strat'], up_neighba['strat'], my_strat['initial'], up_neighba['initial'],  mistake, rounds).score1, play_game(my_strat['strat'], down_neighba['strat'], my_strat['initial'], down_neighba['initial'],  mistake, rounds).score1, play_game(my_strat['strat'], left_neighba['strat'], my_strat['initial'], left_neighba['initial'],  mistake, rounds).score1, play_game(my_strat['strat'], right_neighba['strat'], my_strat['initial'], right_neighba['initial'],  mistake, rounds).score1
    print(f"my_strat: {my_strat}; up,down,left,right respectively: \n", up_neighba, down_neighba, left_neighba, right_neighba)
    print("my payoff against up,down,left,right respectively:\n", payoff_up, payoff_down, payoff_left, payoff_right)
    return payoff_up + payoff_down + payoff_left + payoff_right

def play_lattice(lat, mistake, rounds):
    n = len(lat)
    total_score = []
    for i in range(n):
        total_score.append([])
        for j in range(n):
            total_score[i].append(play_neighbors(lat, i, j, mistake, rounds))
    return total_score




def init_square_lattice(N):
    lattice = []

    strategy_pool = [
        {'c': C,'d': D},
        {'c': C,'d': C},
        {'c': D,'d': D},
        {'c': D,'d': C},
        ]

    for i in range(N):
        lattice.append([])
        for _ in range(N):
            ind = 0 #np.random.choice(range(len(strategy_pool)))
            strat = strategy_pool[ind]
            lattice[i].append(strat)
    return lattice
# ------------

def init_population(N: int) -> list[Player]:
    """ Initialize the population with 25% of each of the four basic strategies.
    Final population will have size 4*N """

    strategy_pool = []

    for first, second, third in itertools.combinations_with_replacement(ALL_ACTIONS, 3):
        new_strat = {
            'c': first,
            'd': second,
            'a': third,
        }
        strategy_pool.append(new_strat)

    # one of 4 strats and one of 2 initials
    player_types = [Player(strat, init) for strat in strategy_pool for init in [C,D]]

    players = []
    for player in player_types:
        players += [copy.deepcopy(player) for i in range(N)]

    return players

def select(population, mistake, rounds):
    """ Selects new population randomely from winners """
    population = play_all(population, mistake, rounds)

    scores = [p.score for p in population]
    score_sum = np.sum(scores)

    new_population = []
    for _ in range(len(population)):
        r = random.random() * score_sum
        for player in population:
            if player.score > r:
                new_population.append(player)
                break
            else:
                r -= player.score

    for p in population:
        p.score = 0

    return new_population

def duplicate(player: Player, max_len) -> Player:

    if player.memory_size < max_len:

        new_strategy = {}
        for key, value in player.strategy.items():
            for action in ALL_ACTIONS:
                new_strategy[(action+key)] = value

        player.strategy = new_strategy
        player.memory_size += 1
        player.initial_state = random.choice([C,D]) + player.initial_state

        return player
    else: 
        return player

def point_mutation(player: Player, mut: float) -> Player:
    # mutate actions
    for key, b in player.strategy.items():
        if random.random() < mut:
            player.strategy[key] = not_action(b)
    #  mutate initial state
    for i in range(len(player.initial_state)):
        if random.random() < mut:
            new_init_state = list(player.initial_state)
            new_init_state[i] = not_action(new_init_state[i])
            player.initial_state = ''.join(new_init_state)

    return player

def split(player: Player) -> Player:
    if player.memory_size == 1:
        return player
    else:
        new_strat = {}
        s = player.strategy
        keys = list(s.keys())

        n_actions = len(ALL_ACTIONS)
        start_idx = random.randint(0,(n_actions-1))
        
        # strart at one random position and keep every nth element
        for key in keys[start_idx::n_actions]:
            new_strat[key[1:]] = s[key]

        player.strategy = new_strat
        # remove first character in initial state
        player.initial_state = player.initial_state[1:]
        player.memory_size -= 1

        return player

def mutate(population, mut, max_len):
    new_population = []
    for player in population:
        new_player = copy.deepcopy(player)
        if random.random() < mut:
            new_player = duplicate(new_player, max_len)
        new_player = point_mutation(new_player, mut)
        if random.random() < mut:
            new_player = split(new_player)

        new_population.append(new_player)
    return new_population

def strat_to_string(gene_dict: dict) -> str:
    """ Converts a dict into a string of actions like 'ccdc' """
    actions = gene_dict.values()
    return ''.join(actions)

def not_action(action):
    """ Returns another action """
    all_actions_copy = copy.deepcopy(ALL_ACTIONS)
    all_actions_copy.remove(action)
    n_actions = len(ALL_ACTIONS)
    return all_actions_copy[random.randint(0,(n_actions-2))]

def print_population(population):
    pop_strs = [strat_to_string(player.strategy) for player in population]
    strats, counts = np.unique(pop_strs, return_counts=True)
    ind = np.argsort(-counts)
    print("Strategies: ", strats[ind], counts[ind])

if __name__ == "__main__":

    init_group_size = 25
    generations = 5

    rounds = 10
    mistake = 0.01
    mut = 0.01

    max_len = 4

    population = init_population(init_group_size)

    print_population(population)

    for i in range(generations):
        start_time = time.time()
        print("Generation", i)

        population = select(population, mistake, rounds)
        population = mutate(population, mut, max_len)

        print_population(population)
        dt = time.time() - start_time
        print(f"⏱️: {dt:2f} [s]")

    # print(play_lattice(init_square_lattice(3), 0, 10))

    print("🏁 Fin")
