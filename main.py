from itertools import repeat
from math import log2
import numpy as np

C = True # Cooperate
D = False # Defect

P1 = 0
P2 = 1

class History:
    def __init__(self):
        self.queue = []
    
    def put(self, action1, action2):
        """ Store the results of a round (the two actions generated by the two
        players) into the history. """
        self.queue.insert(0, (action1, action2))

    def show(self, size, player):
        """ Return the history from the point of view of both players. Returns a
        tuple of one-dimentional arrays """
        history = []
        for i in range((size + 1) // 2):
            p1, p2 = self.queue[i]
            if player == P1:
                history.append(p2)
                history.append(p1)
            if player == P2:
                history.append(p1)
                history.append(p2)
        return history[:size]
    
    def eval(self):
        """ Evaluate the history of the two players for Prisoner's Dilemma,
        where:
                  a2
                C    D
        a1  C  3,3  0,5
            D  5,0  1,1
            """
        score1 = 0
        score2 = 0
        for turn in self.queue:
            a1, a2 = turn
            if (a1 == D and a2 == D):
                score1 += 1
                score2 += 1
            if (a1 == C and a2 == D):
                score1 += 0
                score2 += 5
            if (a1 == D and a2 == C):
                score1 += 5
                score2 += 0
            if (a1 == C and a2 == C):
                score1 += 3
                score2 += 3
        return score1, score2

    def print(self):
        """ Pretty print the history """
        print("P1 | P2")
        print("-------")
        for i in range(len(self.queue) - 1, -1, -1):
            a1, a2 = self.queue[i]
            a1 = 'C' if a1 else 'D'
            a2 = 'C' if a2 else 'D'
            print(" %s | %s " % (a1,a2))

def find_index(history):
    """ Find the strategy index for a particular history. Uses binary encoding
    to get stuff done """
    return sum([bit*2**exp for exp, bit in enumerate(history)])

def play_turn(strat, history, mistake):
    """ Play a single turn for a single player with some probability of a
    mistake happening """
    action = strat[find_index(history)]
    if np.random.uniform() < mistake:
        return not(action)
    else:
        return action

def play_game(strat1, strat2, mistake, rounds):
    """ Play a game between two players from start to finish """
    # Find the largest memory m
    m1 = int(log2(len(strat1)))
    m2 = int(log2(len(strat2)))
    # Create random initial history
    history = History()
    for i in range(max(m1, m2)):
        a1 = np.random.choice([True, False])
        a2 = np.random.choice([True, False])
        history.put(a1,a2)
    # Play the game out
    for r in range(rounds):
        # Player 1 plays
        hist1 = history.show(m1, P1)
        action1 = play_turn(strat1, hist1, mistake)
        # Player 2 plays
        hist2 = history.show(m2, P2)
        action2 = play_turn(strat2, hist2, mistake)
        # Store the results
        history.put(action1, action2)
    return history

def play_all(population, mistake, rounds):
    n = len(population)
    winners = []
    for i in range(n):
        for j in range(n):
            strat1 = population[i]
            strat2 = population[j]
            history = play_game(strat1, strat2, mistake, rounds)
            score1, score2 = history.eval()
            if score1 > score2:
                winners.append(strat1)
            elif score2 > score1:
                winners.append(strat2)
            else:
                if np.random.uniform() < 0.5:
                    winners.append(strat1)
                else:
                    winners.append(strat2)
    return winners

def init_population(N):
    """ Initialize the population with 25% of each of the four basic strategies.
    Final population will have size 4*N """
    a = list(repeat([D,C], N)) # tit for tat
    b = list(repeat([C,C], N)) # all cooperate
    c = list(repeat([D,D], N)) # all defect
    d = list(repeat([C,D], N)) # anti tit for tat
    return a + b + c + d

def select(population, mistake, rounds):
    winners = play_all(population, mistake, rounds)
    indexes = np.random.randint(len(winners), size=len(population))
    return [winners[i] for i in indexes]

def duplicate(gene):
    return gene + gene

def point_mutation(gene, mut):
    for i, b in enumerate(gene):
        if np.random.uniform() < mut:
            gene[i] = not(b)
    return gene

def split(gene):
    if len(gene) == 2:
        return gene
    else:
        half = len(gene) // 2
        return gene[:half] if np.random.uniform() < 0.5 else gene[half:]

def mutate(population, mut):
    new_population = []
    for strat in population:
        if np.random.uniform() < mut:
            strat = duplicate(strat)
        strat = point_mutation(strat, mut)
        if np.random.uniform() < mut:
            strat = split(strat)
        new_population.append(strat)
    return new_population

if __name__ == "__main__":

    init_group_size = 25
    generations = 10

    rounds = 10
    mistake = 0.01
    mut = 0.01

    population = init_population(init_group_size)
    for i in range(generations):
        print("Generation", i)
        population = select(population, mistake, rounds)
        population = mutate(population, mut)

    print("Fin")
