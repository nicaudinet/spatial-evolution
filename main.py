from itertools import repeat
from math import log2
import numpy as np
import random
import time

C = 'c' #True # Cooperate
D = 'd' #False # Defect

P1 = 0
P2 = 1

class History:
    def __init__(self):
        self.p1 = ''
        self.p2 = ''
        self.score1 = 0
        self.score2 = 0
    
    def put(self, action1, action2):
        """ Store the results of a round (the two actions generated by the two
        players) into the history. """

        self.p1 += action1 + action2
        self.p2 += action2 + action1

        self.update_score(action1, action2)

    def update_score(self, a1, a2):
        """ Evaluate the history of the two players for Prisoner's Dilemma,
        where:
                  a2
                C    D
        a1  C  3,3  0,5
            D  5,0  1,1
            """

        if (a1 == D and a2 == D):
            self.score1 += 1
            self.score2 += 1
        if (a1 == C and a2 == D):
            self.score1 += 0
            self.score2 += 5
        if (a1 == D and a2 == C):
            self.score1 += 5
            self.score2 += 0
        if (a1 == C and a2 == C):
            self.score1 += 3
            self.score2 += 3

    def print(self):
        """ Pretty print the history """
        print("P1 | P2")
        print("-------")
        actions = list(self.p1)
        for i in range(0, len(actions), 2):
            a1 = actions[i]
            a2 = actions[i+1]
            print(" %s | %s " % (a1,a2))

def play_turn(strat, history, mistake):
    """ Play a single turn for a single player with some probability of a
    mistake happening """
    action = strat[history]

    if random.random() < mistake:
        return not_action(action)
    else:
        return action

def play_game(strat1, strat2, initial1, initial2, mistake, rounds):
    """ Play a game between two players from start to finish """
    # Find the largest memory m
    m1 = max([len(k) for k in strat1.keys()])
    m2 = max([len(k) for k in strat2.keys()])

    # Create random initial history
    history = History()
    for i in range(max(m1, m2)):
        a1 = initial1
        a2 = initial2
        history.put(a1,a2)
    # Play the game out
    for r in range(rounds):
        # Player 1 plays
        hist1 = history.p1[-m1:]
        action1 = play_turn(strat1, hist1, mistake)
        # Player 2 plays
        hist2 = history.p2[-m2:]
        action2 = play_turn(strat2, hist2, mistake)
        # Store the results
        history.put(action1, action2)
    return history

def play_all(population, mistake, rounds):
    n = len(population)
    winners = []
    for i in range(n):
        for j in range(n):
            strat1 = population[i]
            strat2 = population[j]
            initial1 = population[i]['initial']
            initial2 = population[j]['initial']
            history = play_game(strat1['strat'], strat2['strat'], initial1, initial2, mistake, rounds)
            if history.score1 > history.score2:
                winners.append(strat1)
            elif history.score2 > history.score1:
                winners.append(strat2)
            else:
                if random.random() < 0.5:
                    winners.append(strat1)
                else:
                    winners.append(strat2)
    return winners

# Lattice play
# ------------
def play_neighbors(lat, i, j, mistake, rounds):
    n = len(lat)
    up    = n - 1 if i == 0     else i - 1
    down  = 0     if i == n - 1 else i + 1
    left  = n - 1 if j == 0     else j - 1
    right = 0     if j == n - 1 else j + 1

    # Strats
    my_strat = lat[i][j]
    up_neighba, down_neighba, left_neighba, right_neighba = lat[up][j], lat[down][j], lat[i][left], lat[i][right]
    
    # Result of playing neighbas
    payoff_up, payoff_down, payoff_left, payoff_right = play_game(my_strat['strat'], up_neighba['strat'], my_strat['initial'], up_neighba['initial'],  mistake, rounds).score1, play_game(my_strat['strat'], down_neighba['strat'], my_strat['initial'], down_neighba['initial'],  mistake, rounds).score1, play_game(my_strat['strat'], left_neighba['strat'], my_strat['initial'], left_neighba['initial'],  mistake, rounds).score1, play_game(my_strat['strat'], right_neighba['strat'], my_strat['initial'], right_neighba['initial'],  mistake, rounds).score1
    print(f"my_strat: {my_strat}; up,down,left,right respectively: \n", up_neighba, down_neighba, left_neighba, right_neighba)
    print("my payoff against up,down,left,right respectively:\n", payoff_up, payoff_down, payoff_left, payoff_right)
    return payoff_up + payoff_down + payoff_left + payoff_right

def play_lattice(lat, mistake, rounds):
    n = len(lat)
    total_score = []
    for i in range(n):
        total_score.append([])
        for j in range(n):
            total_score[i].append(play_neighbors(lat, i, j, mistake, rounds))
    return total_score


strategy_pool = [
    {'strat': {'c': C,'d': D},
     'initial': C},
    {'strat': {'c': C,'d': C},
     'initial': C},
    {'strat': {'c': D,'d': D},
     'initial': C},
    {'strat': {'c': D,'d': C},
     'initial': C}
    ]

def init_square_lattice(N):
    lattice = []
    for i in range(N):
        lattice.append([])
        for _ in range(N):
            ind = 0 #np.random.choice(range(len(strategy_pool)))
            strat = strategy_pool[ind]
            lattice[i].append(strat)
    return lattice
# ------------

def init_population(N):
    """ Initialize the population with 25% of each of the four basic strategies.
    Final population will have size 4*N """

    tft      = strategy_pool[0]
    all_coop = strategy_pool[1]
    all_def  = strategy_pool[2]
    anti_tft = strategy_pool[3]

    a = list(repeat(tft, N)) # tit for tat
    b = list(repeat(all_coop, N)) # all cooperate
    c = list(repeat(all_def, N)) # all defect
    d = list(repeat(anti_tft, N)) # anti tit for tat

    return a + b + c + d

def select(population, mistake, rounds):
    """ Selects new population randomely from winners """
    winners = play_all(population, mistake, rounds)
    indexes = np.random.randint(len(winners), size=len(population))
    return [winners[i] for i in indexes]

def duplicate(gene: dict) -> dict:
    new_gene = {}
    for key, value in gene.items():
        new_gene[('c'+key)] = value
        new_gene[('d'+key)] = value

    return new_gene

def point_mutation(gene, mut):
    for key, b in gene.items():
        if random.random() < mut:
            gene[key] = not_action(b)
    return gene

def split(strategy: dict) -> dict:
    m = len(list(strategy.keys())[0])

    if m == 1:
        return strategy
    else:
        new_strat = {}
        s = strategy
        keys = list(s.keys())
        start_idx = np.random.randint(0,2)
        for key in keys[start_idx::2]:
            new_strat[key[1:]] = s[key]
        return new_strat

def mutate(population, mut):
    new_population = []
    for gene in population:
        new_gene = gene
        if random.random() < mut:
            new_gene['strat'] = duplicate(new_gene['strat'])
        new_gene['strat'] = point_mutation(new_gene['strat'], mut)
        if random.random() < mut:
            new_gene['strat'] = split(new_gene['strat'])
        new_population.append(new_gene)
    return new_population

def strat_to_string(gene_dict: dict) -> str:
    """ Converts a dict into a string of actions like 'ccdc' """
    actions = gene_dict.values()
    return ''.join(actions)

def not_action(action):
    """ Returns the opposite action """
    return 'c' if action == 'd' else 'd'

def print_population(population):
    pop_strs = [strat_to_string(gene['strat']) for gene in population]
    strats, counts = np.unique(pop_strs, return_counts=True)
    print("Strategies: ", strats, counts)

if __name__ == "__main__":

    init_group_size = 25
    generations = 10

    rounds = 100
    mistake = 0.01
    mut = 0.01

    population = init_population(init_group_size)

    print_population(population)

    for i in range(generations):
        start_time = time.time()
        print("Generation", i)
        population = select(population, mistake, rounds)
        population = mutate(population, mut)
        print_population(population)
        dt = time.time() - start_time
        print(f"‚è±Ô∏è: {dt:2f} [s]")

    print(play_lattice(init_square_lattice(3), 0, 10))

    print("üèÅ Fin")
