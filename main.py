from itertools import repeat
from math import log2
import numpy as np
import random

C = True # Cooperate
D = False # Defect

P1 = 0
P2 = 1

class History:
    def __init__(self):
        self.queue = []
        self.p1 = []
        self.p2 = []
    
    def put(self, action1, action2):
        """ Store the results of a round (the two actions generated by the two
        players) into the history. """
        self.queue.insert(0, (action1, action2))
        self.p1.insert(0, action1)
        self.p1.insert(0, action2)
        self.p2.insert(0, action2)
        self.p2.insert(0, action1)

    def eval(self):
        """ Evaluate the history of the two players for Prisoner's Dilemma,
        where:
                  a2
                C    D
        a1  C  3,3  0,5
            D  5,0  1,1
            """
        score1 = 0
        score2 = 0
        for turn in self.queue:
            a1, a2 = turn
            if (a1 == D and a2 == D):
                score1 += 1
                score2 += 1
            if (a1 == C and a2 == D):
                score1 += 0
                score2 += 5
            if (a1 == D and a2 == C):
                score1 += 5
                score2 += 0
            if (a1 == C and a2 == C):
                score1 += 3
                score2 += 3
        return score1, score2

    def print(self):
        """ Pretty print the history """
        print("P1 | P2")
        print("-------")
        for i in range(len(self.queue) - 1, -1, -1):
            a1, a2 = self.queue[i]
            a1 = 'C' if a1 else 'D'
            a2 = 'C' if a2 else 'D'
            print(" %s | %s " % (a1,a2))

def find_index(history):
    """ Find the strategy index for a particular history. Uses binary encoding
    to get stuff done """
    return sum([bit*2**exp for exp, bit in enumerate(history)])

def play_turn(strat, history, mistake):
    """ Play a single turn for a single player with some probability of a
    mistake happening """
    action = strat[find_index(history)]
    if random.random() < mistake:
        return not(action)
    else:
        return action

def play_game(strat1, strat2, mistake, rounds):
    """ Play a game between two players from start to finish """
    # Find the largest memory m
    m1 = int(log2(len(strat1)))
    m2 = int(log2(len(strat2)))
    # Create random initial history
    history = History()
    for i in range(max(m1, m2)):
        a1 = random.choice([True, False])
        a2 = random.choice([True, False])
        history.put(a1,a2)
    # Play the game out
    for r in range(rounds):
        # Player 1 plays
        hist1 = history.p1[:m1]
        action1 = play_turn(strat1, hist1, mistake)
        # Player 2 plays
        hist2 = history.p2[:m2]
        action2 = play_turn(strat2, hist2, mistake)
        # Store the results
        history.put(action1, action2)
    return history

def play_all(population, mistake, rounds):
    n = len(population)
    winners = []
    for i in range(n):
        for j in range(n):
            strat1 = population[i]
            strat2 = population[j]
            history = play_game(strat1, strat2, mistake, rounds)
            score1, score2 = history.eval()
            if score1 > score2:
                winners.append(strat1)
            elif score2 > score1:
                winners.append(strat2)
            else:
                if random.random() < 0.5:
                    winners.append(strat1)
                else:
                    winners.append(strat2)
    return winners

# Lattice play
# ------------
def play_neighbors(lat, i, j, mistake, rounds):
    n = len(lat)
    up    = n - 1 if i == 0     else i - 1
    down  = 0     if i == n - 1 else i + 1
    left  = n - 1 if j == 0     else j - 1
    right = 0     if j == n - 1 else j + 1

    # Strats
    my_strat = lat[i][j]
    up_neighba, down_neighba, left_neighba, right_neighba = lat[up][j], lat[down][j], lat[i][left], lat[i][right]
    
    # Result of playing neighbas
    [payoff_up, _], [payoff_down, _], [payoff_left, _], [payoff_right, _] = play_game(my_strat, up_neighba, mistake, rounds).eval(), play_game(my_strat, down_neighba, mistake, rounds).eval(), play_game(my_strat, left_neighba, mistake, rounds).eval(), play_game(my_strat, right_neighba, mistake, rounds).eval()
    print(f"my_strat: {my_strat}; up,down,left,right respectively: \n", up_neighba, down_neighba, left_neighba, right_neighba)
    print("my payoff against up,down,left,right respectively:\n", payoff_up, payoff_down, payoff_left, payoff_right)
    return payoff_up + payoff_down + payoff_left + payoff_right

def play_lattice(lat, mistake, rounds):
    n = len(lat)
    total_score = []
    for i in range(n):
        total_score.append([])
        for j in range(n):
            total_score[i].append(play_neighbors(lat, i, j, mistake, rounds))
    return total_score


strategy_pool = [ [D,C] , [C,C], [D,D], [C,D] ]

def init_square_lattice(N):
    lattice = []
    for i in range(N):
        lattice.append([])
        for _ in range(N):
            ind = 0 #np.random.choice(range(len(strategy_pool)))
            strat = strategy_pool[ind]
            lattice[i].append(strat)
    return lattice
# ------------

def init_population(N):
    """ Initialize the population with 25% of each of the four basic strategies.
    Final population will have size 4*N """
    a = list(repeat([D,C], N)) # tit for tat
    b = list(repeat([C,C], N)) # all cooperate
    c = list(repeat([D,D], N)) # all defect
    d = list(repeat([C,D], N)) # anti tit for tat
    return a + b + c + d

def select(population, mistake, rounds):
    winners = play_all(population, mistake, rounds)
    indexes = np.random.randint(len(winners), size=len(population))
    return [winners[i] for i in indexes]

def duplicate(gene):
    return gene + gene

def point_mutation(gene, mut):
    for i, b in enumerate(gene):
        if random.random() < mut:
            gene[i] = not(b)
    return gene

def split(gene):
    if len(gene) == 2:
        return gene
    else:
        half = len(gene) // 2
        return gene[:half] if random.random() < 0.5 else gene[half:]

def mutate(population, mut):
    new_population = []
    for strat in population:
        if random.random() < mut:
            strat = duplicate(strat)
        strat = point_mutation(strat, mut)
        if random.random() < mut:
            strat = split(strat)
        new_population.append(strat)
    return new_population

if __name__ == "__main__":

    init_group_size = 25
    generations = 3

    rounds = 10
    mistake = 0.01
    mut = 0.01

    population = init_population(init_group_size)
    for i in range(generations):
        print("Generation", i)
        population = select(population, mistake, rounds)
        population = mutate(population, mut)

    print(play_lattice(init_square_lattice(3), 0, 10))

    print("Fin")
