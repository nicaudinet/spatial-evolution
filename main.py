from itertools import repeat
from math import log2
import numpy as np
import random
import time

C = 'c' #True # Cooperate
D = 'd' #False # Defect

P1 = 0
P2 = 1

class History:
    def __init__(self):
        self.p1 = ''
        self.p2 = ''
        self.score1 = 0
        self.score2 = 0
    
    def put(self, action1, action2):
        """ Store the results of a round (the two actions generated by the two
        players) into the history. """

        self.p1 += action1 + action2
        self.p2 += action2 + action1

        self.update_score(action1, action2)

    def update_score(self, a1, a2):
        """ Evaluate the history of the two players for Prisoner's Dilemma,
        where:
                  a2
                C    D
        a1  C  3,3  0,5
            D  5,0  1,1
            """

        if (a1 == D and a2 == D):
            self.score1 += 1
            self.score2 += 1
        if (a1 == C and a2 == D):
            self.score1 += 0
            self.score2 += 5
        if (a1 == D and a2 == C):
            self.score1 += 5
            self.score2 += 0
        if (a1 == C and a2 == C):
            self.score1 += 3
            self.score2 += 3

    def print(self):
        """ Pretty print the history """
        print("P1 | P2")
        print("-------")
        actions = list(self.p1)
        for i in range(0, len(actions), 2):
            a1 = actions[i]
            a2 = actions[i+1]
            print(" %s | %s " % (a1,a2))

def play_turn(strat, history, mistake):
    """ Play a single turn for a single player with some probability of a
    mistake happening """
    action = strat[history]

    if random.random() < mistake:
        return not_action(action)
    else:
        return action

def play_game(strat1, strat2, mistake, rounds):
    """ Play a game between two players from start to finish """
    # Find the largest memory m
    m1 = max([len(k) for k in strat1.keys()])
    m2 = max([len(k) for k in strat2.keys()])

    # Create random initial history
    history = History()
    for i in range(max(m1, m2)):
        a1 = random.choice([C, D])
        a2 = random.choice([C, D])
        history.put(a1,a2)
    # Play the game out
    for r in range(rounds):
        # Player 1 plays
        hist1 = history.p1[-m1:]
        action1 = play_turn(strat1, hist1, mistake)
        # Player 2 plays
        hist2 = history.p2[-m2:]
        action2 = play_turn(strat2, hist2, mistake)
        # Store the results
        history.put(action1, action2)
    return history

def play_all(population, mistake, rounds):
    n = len(population)
    winners = []
    for i in range(n):
        for j in range(n):
            strat1 = population[i]
            strat2 = population[j]
            history = play_game(strat1, strat2, mistake, rounds)
            if history.score1 > history.score2:
                winners.append(strat1)
            elif history.score2 > history.score1:
                winners.append(strat2)
            else:
                if random.random() < 0.5:
                    winners.append(strat1)
                else:
                    winners.append(strat2)
    return winners

def init_population(N):
    """ Initialize the population with 25% of each of the four basic strategies.
    Final population will have size 4*N """

    tft = {
        'c': C,
        'd': D,
    }
    all_coop = {
        'c': C,
        'd': C,
    }
    all_def = {
        'c': D,
        'd': D,
    }
    anti_tft = {
        'c': D,
        'd': C,
    }

    a = list(repeat(tft, N)) # tit for tat
    b = list(repeat(all_coop, N)) # all cooperate
    c = list(repeat(all_def, N)) # all defect
    d = list(repeat(anti_tft, N)) # anti tit for tat

    return a + b + c + d

def select(population, mistake, rounds):
    """ Selects new population randomely from winners """
    winners = play_all(population, mistake, rounds)
    indexes = np.random.randint(len(winners), size=len(population))
    return [winners[i] for i in indexes]

def duplicate(gene: dict) -> dict:
    new_gene = {}
    for key, value in gene.items():
        new_gene[('c'+key)] = value
        new_gene[('d'+key)] = value

    return new_gene

def point_mutation(gene, mut):
    for key, b in gene.items():
        if random.random() < mut:
            gene[key] = not_action(b)
    return gene

def split(strategy: dict) -> dict:
    m = len(list(strategy.keys())[0])

    if m == 1:
        return strategy
    else:
        new_strat = {}
        keys = list(strategy.keys())
        start_idx = np.random.randint(0,2)

        for key in keys[start_idx::2]:
            new_strat[key[1:]] = strategy[key]

        return new_strat

def mutate(population, mut):
    new_population = []
    for strat in population:
        if random.random() < mut:
            strat = duplicate(strat)
        strat = point_mutation(strat, mut)
        if random.random() < mut:
            strat = split(strat)
        new_population.append(strat)
    return new_population

def strat_to_string(gene_dict: dict) -> str:
    """ Converts a dict into a string of actions like 'ccdc' """
    actions = gene_dict.values()
    return ''.join(actions)

def not_action(action):
    """ Returns the opposite action """
    return 'c' if action == 'd' else 'd'

def print_population(population):
    pop_strs = [strat_to_string(strat) for strat in population]
    strats, counts = np.unique(pop_strs, return_counts=True)
    print("Strategies: ", strats, counts)

if __name__ == "__main__":

    init_group_size = 25
    generations = 10

    rounds = 100
    mistake = 0.01
    mut = 0.01

    population = init_population(init_group_size)

    print_population(population)

    for i in range(generations):
        start_time = time.time()
        print("Generation", i)
        population = select(population, mistake, rounds)
        population = mutate(population, mut)
        print_population(population)
        dt = time.time() - start_time
        print(f"‚è±Ô∏è: {dt:2f} [s]")

    print("üèÅ Fin")